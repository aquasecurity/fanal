// Code generated by mockery v1.0.0. DO NOT EDIT.

package cache

import (
	types "github.com/aquasecurity/fanal/types"
	mock "github.com/stretchr/testify/mock"
)

// MockLocalImageCache is an autogenerated mock type for the LocalImageCache type
type MockLocalImageCache struct {
	mock.Mock
}

type LocalImageCacheClearReturns struct {
	Err error
}

type LocalImageCacheClearExpectation struct {
	Returns LocalImageCacheClearReturns
}

func (_m *MockLocalImageCache) ApplyClearExpectation(e LocalImageCacheClearExpectation) {
	var args []interface{}
	_m.On("Clear", args...).Return(e.Returns.Err)
}

func (_m *MockLocalImageCache) ApplyClearExpectations(expectations []LocalImageCacheClearExpectation) {
	for _, e := range expectations {
		_m.ApplyClearExpectation(e)
	}
}

// Clear provides a mock function with given fields:
func (_m *MockLocalImageCache) Clear() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type LocalImageCacheCloseReturns struct {
	Err error
}

type LocalImageCacheCloseExpectation struct {
	Returns LocalImageCacheCloseReturns
}

func (_m *MockLocalImageCache) ApplyCloseExpectation(e LocalImageCacheCloseExpectation) {
	var args []interface{}
	_m.On("Close", args...).Return(e.Returns.Err)
}

func (_m *MockLocalImageCache) ApplyCloseExpectations(expectations []LocalImageCacheCloseExpectation) {
	for _, e := range expectations {
		_m.ApplyCloseExpectation(e)
	}
}

// Close provides a mock function with given fields:
func (_m *MockLocalImageCache) Close() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type LocalImageCacheGetImageArgs struct {
	ImageID         string
	ImageIDAnything bool
}

type LocalImageCacheGetImageReturns struct {
	ImageInfo types.ImageInfo
	Err       error
}

type LocalImageCacheGetImageExpectation struct {
	Args    LocalImageCacheGetImageArgs
	Returns LocalImageCacheGetImageReturns
}

func (_m *MockLocalImageCache) ApplyGetImageExpectation(e LocalImageCacheGetImageExpectation) {
	var args []interface{}
	if e.Args.ImageIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.ImageID)
	}
	_m.On("GetImage", args...).Return(e.Returns.ImageInfo, e.Returns.Err)
}

func (_m *MockLocalImageCache) ApplyGetImageExpectations(expectations []LocalImageCacheGetImageExpectation) {
	for _, e := range expectations {
		_m.ApplyGetImageExpectation(e)
	}
}

// GetImage provides a mock function with given fields: imageID
func (_m *MockLocalImageCache) GetImage(imageID string) (types.ImageInfo, error) {
	ret := _m.Called(imageID)

	var r0 types.ImageInfo
	if rf, ok := ret.Get(0).(func(string) types.ImageInfo); ok {
		r0 = rf(imageID)
	} else {
		r0 = ret.Get(0).(types.ImageInfo)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(imageID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type LocalImageCacheGetLayerArgs struct {
	DiffID         string
	DiffIDAnything bool
}

type LocalImageCacheGetLayerReturns struct {
	LayerInfo types.LayerInfo
	Err       error
}

type LocalImageCacheGetLayerExpectation struct {
	Args    LocalImageCacheGetLayerArgs
	Returns LocalImageCacheGetLayerReturns
}

func (_m *MockLocalImageCache) ApplyGetLayerExpectation(e LocalImageCacheGetLayerExpectation) {
	var args []interface{}
	if e.Args.DiffIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.DiffID)
	}
	_m.On("GetLayer", args...).Return(e.Returns.LayerInfo, e.Returns.Err)
}

func (_m *MockLocalImageCache) ApplyGetLayerExpectations(expectations []LocalImageCacheGetLayerExpectation) {
	for _, e := range expectations {
		_m.ApplyGetLayerExpectation(e)
	}
}

// GetLayer provides a mock function with given fields: diffID
func (_m *MockLocalImageCache) GetLayer(diffID string) (types.LayerInfo, error) {
	ret := _m.Called(diffID)

	var r0 types.LayerInfo
	if rf, ok := ret.Get(0).(func(string) types.LayerInfo); ok {
		r0 = rf(diffID)
	} else {
		r0 = ret.Get(0).(types.LayerInfo)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(diffID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
